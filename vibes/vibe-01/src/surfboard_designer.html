<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hollow Wooden Surfboard CAD</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React and ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: white; }
        canvas { display: block; }
        .control-panel {
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(10px);
        }
        /* Custom scrollbar for controls */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #666; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- ICONS (Inline SVGs to remove external dependencies) ---
        const IconLayers = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polygon points="12 2 2 7 12 12 22 7 12 2" />
                <polyline points="2 17 12 22 22 17" />
                <polyline points="2 12 12 17 22 12" />
            </svg>
        );

        const IconFileJson = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
                <polyline points="14 2 14 8 20 8" />
                <path d="M10 12a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1" />
                <path d="M10 18a1 1 0 0 0-1-1v-2a1 1 0 0 0 1-1" />
            </svg>
        );

        // --- 3D UTILITIES ---

        /**
         * Generates a surfboard geometry based on parametric inputs.
         * This uses a simplified algorithm for real-time browser preview.
         * The Python backend handles the heavy B-Spline math for manufacturing.
         */
        const generateSurfboardGeometry = (params) => {
            const { length, width, thickness, noseRocker, tailRocker, widthOffset, thicknessOffset } = params;
            
            // Convert dimensions to relative units for the 3D mesh (scaled down for viewing)
            // 1 unit = 1 foot approx in viewing space, but we store real dims
            const L = length; 
            const W = width / 12.0; // Convert inches to feet for aspect ratio
            const T = thickness / 12.0;
            const NR = noseRocker / 12.0;
            const TR = tailRocker / 12.0;

            // Geometry resolution
            const segmentsL = 60; // Lengthwise segments
            const segmentsW = 30; // Widthwise segments

            const geometry = new THREE.BufferGeometry();
            const indices = [];
            const vertices = [];
            const uvs = [];

            // Helper to compute width at specific length percentage (0 to 1)
            // Simple parabolic curve approximation for outline
            const getWidthAt = (t) => {
                // Shift the wide point
                // Basic outline curve logic (parabolic taper)
                // We use sine wave for basic outline but could use bezier in future
                // Shift 't' based on widthOffset
                // widthOffset is -20 to +20. Map to -0.2 to 0.2
                // We distort the domain 't' to shift the peak
                
                // Simple shift approach:
                // Normal sine peak is at 0.5.
                // We want peak at 0.5 - offset.
                
                // Let's use a composite curve for cleaner wide point shifting
                const peak = 0.5 - (widthOffset / 100);
                
                let w = 0;
                if (t < peak) {
                    // Nose to Wide Point
                    // Normalize t to 0..1 range for this section
                    const t_local = t / peak;
                    w = Math.sin(t_local * Math.PI / 2);
                } else {
                    // Wide Point to Tail
                    const t_local = (t - peak) / (1 - peak);
                    w = Math.cos(t_local * Math.PI / 2);
                }

                return w * W;
            };

            // Helper to compute thickness at specific length percentage
            // Foil distribution
            const getThicknessAt = (t) => {
                const peak = 0.5 - (thicknessOffset / 100);
                let thick = 0;
                
                if (t < peak) {
                    const t_local = t / peak;
                    thick = Math.sin(t_local * Math.PI / 2);
                } else {
                    const t_local = (t - peak) / (1 - peak);
                    thick = Math.cos(t_local * Math.PI / 2);
                }
                return thick * T;
            };

            // Helper to compute Rocker (Height Y) at specific length
            const getRockerAt = (t) => {
                // Parabolic rocker curve
                // t=0 is tail, t=1 is nose
                // Tail rocker affects t=0, Nose rocker affects t=1
                // Simple quadratic blend
                const tailCurve = Math.pow(1 - t, 2) * TR;
                const noseCurve = Math.pow(t, 2) * NR;
                return noseCurve + tailCurve; 
            };

            // Generate vertices
            for (let i = 0; i <= segmentsL; i++) {
                const t = i / segmentsL; // 0 to 1 along length
                const x = (t - 0.5) * L; // Center board on X axis
                
                const currentWidth = getWidthAt(t);
                const currentThickness = getThicknessAt(t);
                const currentRocker = getRockerAt(t);

                for (let j = 0; j <= segmentsW; j++) {
                    const u = j / segmentsW; // 0 to 1 along width (circumference)
                    
                    // Elliptical cross section logic
                    const angle = u * Math.PI * 2;
                    
                    // Z is width-wise, Y is vertical (thickness + rocker)
                    // We modify Y by rocker
                    const zPos = (Math.cos(angle) * currentWidth) / 2;
                    const yLocal = (Math.sin(angle) * currentThickness) / 2;
                    
                    const yPos = yLocal + currentRocker;

                    vertices.push(x, yPos, zPos);
                    uvs.push(t, u);
                }
            }

            // Generate indices
            for (let i = 0; i < segmentsL; i++) {
                for (let j = 0; j < segmentsW; j++) {
                    const a = i * (segmentsW + 1) + j;
                    const b = (i + 1) * (segmentsW + 1) + j;
                    const c = (i + 1) * (segmentsW + 1) + (j + 1);
                    const d = i * (segmentsW + 1) + (j + 1);

                    // Two triangles per quad
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }

            geometry.setIndex(indices);
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geometry.computeVertexNormals();

            return geometry;
        };


        // --- COMPONENTS ---

        const ControlSlider = ({ label, value, min, max, step, onChange, unit = "" }) => (
            <div className="mb-4">
                <div className="flex justify-between mb-1">
                    <span className="text-sm text-gray-400 font-medium">{label}</span>
                    <span className="text-sm text-cyan-400 font-mono">{value} {unit}</span>
                </div>
                <input
                    type="range"
                    min={min}
                    max={max}
                    step={step}
                    value={value}
                    onChange={(e) => onChange(parseFloat(e.target.value))}
                    className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-cyan-500 hover:accent-cyan-400 transition-all"
                />
            </div>
        );

        const App = () => {
            const mountRef = useRef(null);
            
            // Design Parameters State
            const [params, setParams] = useState({
                length: 7.2,       // Feet
                width: 21.5,       // Inches
                thickness: 2.75,   // Inches
                noseRocker: 4.5,   // Inches
                tailRocker: 2.5,   // Inches
                widthOffset: 0,    // % shift of wide point
                thicknessOffset: 0 // % shift of thickest point
            });

            // 3D Scene Refs
            const sceneRef = useRef(null);
            const meshRef = useRef(null);
            const rendererRef = useRef(null);
            const cameraRef = useRef(null);
            const frameIdRef = useRef(null);

            // Initialize Three.js
            useEffect(() => {
                const width = mountRef.current.clientWidth;
                const height = mountRef.current.clientHeight;

                // Scene setup
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a1a1a);
                // Add grid
                const gridHelper = new THREE.GridHelper(20, 20, 0x333333, 0x222222);
                scene.add(gridHelper);

                // Camera
                const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
                camera.position.set(5, 5, 10);
                camera.lookAt(0, 0, 0);

                // Renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(window.devicePixelRatio);
                mountRef.current.appendChild(renderer.domElement);

                // Lights
                const ambientLight = new THREE.AmbientLight(0x404040, 2);
                scene.add(ambientLight);
                
                const dirLight = new THREE.DirectionalLight(0xffffff, 1);
                dirLight.position.set(5, 10, 7);
                scene.add(dirLight);
                
                const dirLight2 = new THREE.DirectionalLight(0x00aabb, 0.5);
                dirLight2.position.set(-5, -2, -5);
                scene.add(dirLight2);

                // Initial Material
                const material = new THREE.MeshPhysicalMaterial({
                    color: 0xd2b48c, // Wood color
                    roughness: 0.3,
                    metalness: 0.1,
                    clearcoat: 0.5,
                    clearcoatRoughness: 0.1,
                    side: THREE.DoubleSide,
                    wireframe: false
                });

                // Mesh Placeholder
                const geometry = new THREE.BoxGeometry(1,1,1);
                const mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);

                sceneRef.current = scene;
                meshRef.current = mesh;
                rendererRef.current = renderer;
                cameraRef.current = camera;

                // Animation Loop (Orbit controls logic simulated manually for simplicity)
                let angle = 0;
                const animate = () => {
                    angle += 0.002;
                    // Simple auto-rotate if user isn't interacting (omitted for clean code)
                    // camera.position.x = Math.sin(angle) * 12;
                    // camera.position.z = Math.cos(angle) * 12;
                    // camera.lookAt(0, 0, 0);
                    
                    renderer.render(scene, camera);
                    frameIdRef.current = requestAnimationFrame(animate);
                };
                animate();

                // Handle Resize
                const handleResize = () => {
                    if (!mountRef.current) return;
                    const w = mountRef.current.clientWidth;
                    const h = mountRef.current.clientHeight;
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                    renderer.setSize(w, h);
                };
                window.addEventListener('resize', handleResize);

                return () => {
                    window.removeEventListener('resize', handleResize);
                    cancelAnimationFrame(frameIdRef.current);
                    if (mountRef.current && renderer.domElement) {
                        mountRef.current.removeChild(renderer.domElement);
                    }
                };
            }, []);

            // Update Geometry when params change
            useEffect(() => {
                if (!meshRef.current) return;
                
                const oldGeo = meshRef.current.geometry;
                const newGeo = generateSurfboardGeometry(params);
                
                meshRef.current.geometry = newGeo;
                
                // Cleanup old geometry memory
                if (oldGeo) oldGeo.dispose();

            }, [params]);

            // Handlers
            const handleExport = () => {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(params, null, 2));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", "my_surfboard_design.json");
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            };

            const updateParam = (key, val) => {
                setParams(prev => ({ ...prev, [key]: val }));
            };

            return (
                <div className="flex h-screen w-screen overflow-hidden font-sans">
                    
                    {/* Left Sidebar - Controls */}
                    <div className="w-80 flex-shrink-0 control-panel h-full border-r border-gray-800 flex flex-col z-10 relative shadow-2xl">
                        <div className="p-6 border-b border-gray-800">
                            <h1 className="text-xl font-bold flex items-center gap-2 text-cyan-400">
                                <IconLayers size={24} />
                                AtomBoard CAD
                            </h1>
                            <p className="text-xs text-gray-500 mt-1">Hollow Wood Framework</p>
                        </div>

                        <div className="flex-1 overflow-y-auto p-6">
                            <h2 className="text-xs uppercase tracking-wider text-gray-500 font-bold mb-4">Dimensions</h2>
                            
                            <ControlSlider 
                                label="Length (ft)" 
                                value={params.length} 
                                min={5} max={12} step={0.1} 
                                onChange={(v) => updateParam('length', v)} 
                            />
                            <ControlSlider 
                                label="Width (in)" 
                                value={params.width} 
                                min={18} max={26} step={0.125} 
                                onChange={(v) => updateParam('width', v)} 
                            />
                            <ControlSlider 
                                label="Thickness (in)" 
                                value={params.thickness} 
                                min={2} max={4} step={0.0625} 
                                onChange={(v) => updateParam('thickness', v)} 
                            />

                            <div className="h-px bg-gray-800 my-6"></div>
                            
                            <h2 className="text-xs uppercase tracking-wider text-gray-500 font-bold mb-4">Rocker Profile</h2>
                            <ControlSlider 
                                label="Nose Rocker (in)" 
                                value={params.noseRocker} 
                                min={1} max={8} step={0.125} 
                                onChange={(v) => updateParam('noseRocker', v)} 
                            />
                            <ControlSlider 
                                label="Tail Rocker (in)" 
                                value={params.tailRocker} 
                                min={0.5} max={5} step={0.125} 
                                onChange={(v) => updateParam('tailRocker', v)} 
                            />

                            <div className="h-px bg-gray-800 my-6"></div>

                            <h2 className="text-xs uppercase tracking-wider text-gray-500 font-bold mb-4">Distribution</h2>
                            <ControlSlider 
                                label="Wide Point Shift (%)" 
                                value={params.widthOffset} 
                                min={-20} max={20} step={1} 
                                onChange={(v) => updateParam('widthOffset', v)} 
                                unit="%"
                            />
                             <ControlSlider 
                                label="Thickness Shift (%)" 
                                value={params.thicknessOffset} 
                                min={-20} max={20} step={1} 
                                onChange={(v) => updateParam('thicknessOffset', v)} 
                                unit="%"
                            />
                        </div>

                        <div className="p-6 border-t border-gray-800 bg-gray-900">
                            <button 
                                onClick={handleExport}
                                className="w-full bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center gap-2 transition-colors"
                            >
                                <IconFileJson size={18} />
                                Export Design JSON
                            </button>
                            <p className="text-[10px] text-gray-500 text-center mt-3">
                                Download for Python processing
                            </p>
                        </div>
                    </div>

                    {/* Main Viewport */}
                    <div className="flex-1 relative bg-black">
                        <div ref={mountRef} className="w-full h-full cursor-move" />
                        
                        <div className="absolute top-6 right-6 flex gap-2">
                             <div className="bg-black/50 backdrop-blur px-4 py-2 rounded-full text-xs text-gray-300 border border-gray-700">
                                Left Click + Drag to Rotate (Simulated)
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>